us50Two <- us50Two[order(us50Two$DRAWSEQ) , ]
us50$PercOfPolsSupp <- us50Two$PercOfPolsSupp
us50$PercOfPolsOpp <- us50Two$PercOfPolsOpp
# Map
map <- get_map(location = "USA", zoom=4, maptype="roadmap", color = "bw")
ggmap(map)
#plot all states with ggplot
# Fixed the bounding problem: http://www.exegetic.biz/blog/2013/12/contour-and-density-layers-with-ggmap/
mapIt <- function(var){
plotVar=all_states[,var]
ggmap(map,extent = "normal", maprange=FALSE) +
geom_polygon(data=all_states, aes(x=long, y=lat, group=group, fill=plotVar), colour=NA, alpha=0.7) +
scale_fill_gradientn(colours=(brewer.pal(9,"YlGnBu"))) +
labs(fill="") +
theme_nothing(legend=TRUE) + ggtitle("Politicians Per Million")
ggsave(paste("./plots/Map7.png"), dpi=300, width=6, height=5)
}
mapIt('PercOfPolsSupp')
mapIt('PercOfPolsSupp',)
mapIt('PercOfPolsSupp')
plotVar=all_states[,var]
library(choroplethr)
PolsByState <- read.csv("./data/PolsByState.csv")
# Prepare
PolsByState$region <- tolower(PolsByState$State)
PolsByState$value <- PolsByState$PercOfPolsOpp * 100
state_choropleth(PolsByState)
library(choroplethrMaps)
install.packages('choroplethrMaps')
library(choroplethrMaps)
# Prepare
PolsByState$region <- tolower(PolsByState$State)
PolsByState$value <- PolsByState$PercOfPolsOpp * 100
state_choropleth(PolsByState)
choro = StateChoropleth$new(PolsByState)
choro$title = "2012 Election Results"
choro$ggplot_scale = scale_fill_gradientn(colours=(brewer.pal(9,"YlGnBu")))
choro$render()
choro$render()
# Politicians For and Against Gay Marriage
# Created by Daniel Hadley to analyze the support for gay marriage
# Nov, 2014
# setwd("/Users/dphnrome/Documents/Git/SameSexMarriage/")
setwd("C:/Users/dhadley/Documents/GitHub/SameSexMarriage")
#### Load packages and data ####
# load data, which was scraped from wikipedia on Nov 16th, 2014
PolsByState <- read.csv("./data/PolsByState.csv")
library(choroplethr)
library(choroplethrMaps)
# Prepare
PolsByState$region <- tolower(PolsByState$State)
PolsByState$value <- PolsByState$PercOfPolsOpp * 100
choro = StateChoropleth$new(PolsByState)
choro$title = "2012 Election Results"
choro$ggplot_scale = scale_fill_gradientn(colours=(brewer.pal(9,"YlGnBu")))
choro$render()
data(df_president)
View(df_president)
choro = StateChoropleth$new(PolsByState)
choro$title = "2012 Election Results"
choro$ggplot_scale = scale_fill_brewer(name="Population", palette=2) # scale_fill_gradientn(colours=(brewer.pal(9,"YlGnBu")))
choro$render()
choro = StateChoropleth$new(PolsByState)
choro$title = "2012 Election Results"
choro$ggplot_scale = scale_fill_brewer(name="Population", palette="YlGnBu") # scale_fill_gradientn(colours=(brewer.pal(9,"YlGnBu")))
choro$render()
StateChoropleth = R6Class("StateChoropleth",
inherit = choroplethr:::Choropleth,
public = list(
# initialize with us state map
initialize = function(user.df)
{
data(state.map)
super$initialize(state.map, user.df)
},
# render the map, with AK and HI as insets
render = function(num_buckets=7)
{
stopifnot(num_buckets > 1 && num_buckets < 10)
self$num_buckets = num_buckets
self$prepare_map()
# if user requested to render all 50 states,
# create separate data.frames for AK and HI and render them as separate images
# cache min, max value of entire data.frame to make scales consistent between all 3 images
min_val = 0
max_val = 0
if (is.numeric(self$choropleth.df$value))
{
min_val = min(self$choropleth.df$value)
max_val = max(self$choropleth.df$value)
}
# subset AK and render it
alaska.df     = self$choropleth.df[self$choropleth.df$region=='alaska',]
alaska.ggplot = render_helper(alaska.df, "", self$theme_inset(), min_val, max_val)
alaska.grob   = ggplotGrob(alaska.ggplot)
# subset HI and render it
hawaii.df     = self$choropleth.df[self$choropleth.df$region=='hawaii',]
hawaii.ggplot = render_helper(hawaii.df, "", self$theme_inset(), min_val, max_val)
hawaii.grob   = ggplotGrob(hawaii.ggplot)
# remove AK and HI from the "real" df
continental.df = self$choropleth.df[!self$choropleth.df$region %in% c("alaska", "hawaii"), ]
continental.ggplot = render_helper(continental.df, self$scale_name, self$theme_clean(), min_val, max_val) + ggtitle(self$title)
continental.ggplot +
annotation_custom(grobTree(hawaii.grob), xmin=-107.5, xmax=-102.5, ymin=25, ymax=27.5) +
annotation_custom(grobTree(alaska.grob), xmin=-125, xmax=-110, ymin=22.5, ymax=30) +
ggtitle(self$title)
},
render_helper = function(choropleth.df, scale_name, theme, min, max)
{
# maps with numeric values are mapped with a continuous scale
if (is.numeric(choropleth.df$value))
{
ggplot(choropleth.df, aes(long, lat, group = group)) +
geom_polygon(aes(fill = value), color = "dark grey", size = 0.2) +
get_scale() +
theme;
} else { # assume character or factor
stopifnot(length(unique(na.omit(choropleth.df$value))) <= 9) # brewer scale only goes up to 9
ggplot(choropleth.df, aes(long, lat, group = group)) +
geom_polygon(aes(fill = value), color = "dark grey", size = 0.2) +
get_scale() +
theme;
}
}
)
)
# create a map with population estimates
data(df_pop_state)
choro = StateChoropleth$new(df_pop_state)
choro$render()
StateChoropleth = R6Class("StateChoropleth",
inherit = choroplethr:::Choropleth,
public = list(
# initialize with us state map
initialize = function(user.df)
{
data(state.map)
super$initialize(state.map, user.df)
},
# render the map, with AK and HI as insets
render = function(num_buckets=7)
{
stopifnot(num_buckets > 1 && num_buckets < 10)
self$num_buckets = num_buckets
self$prepare_map()
# if user requested to render all 50 states,
# create separate data.frames for AK and HI and render them as separate images
# cache min, max value of entire data.frame to make scales consistent between all 3 images
min_val = 0
max_val = 0
if (is.numeric(self$choropleth.df$value))
{
min_val = min(self$choropleth.df$value)
max_val = max(self$choropleth.df$value)
}
# subset AK and render it
alaska.df     = self$choropleth.df[self$choropleth.df$region=='alaska',]
alaska.ggplot = render_helper(alaska.df, "", self$theme_inset(), min_val, max_val)
alaska.grob   = ggplotGrob(alaska.ggplot)
# subset HI and render it
hawaii.df     = self$choropleth.df[self$choropleth.df$region=='hawaii',]
hawaii.ggplot = render_helper(hawaii.df, "", self$theme_inset(), min_val, max_val)
hawaii.grob   = ggplotGrob(hawaii.ggplot)
# remove AK and HI from the "real" df
continental.df = self$choropleth.df[!self$choropleth.df$region %in% c("alaska", "hawaii"), ]
continental.ggplot = render_helper(continental.df, self$scale_name, self$theme_clean(), min_val, max_val) + ggtitle(self$title)
continental.ggplot +
annotation_custom(grobTree(hawaii.grob), xmin=-107.5, xmax=-102.5, ymin=25, ymax=27.5) +
annotation_custom(grobTree(alaska.grob), xmin=-125, xmax=-110, ymin=22.5, ymax=30) +
ggtitle(self$title)
},
render_helper = function(choropleth.df, scale_name, theme, min, max)
{
# maps with numeric values are mapped with a continuous scale
if (is.numeric(choropleth.df$value))
{
ggplot(choropleth.df, aes(long, lat, group = group)) +
geom_polygon(aes(fill = value), color = "dark grey", size = 0.2) +
get_scale() +
theme;
} else { # assume character or factor
stopifnot(length(unique(na.omit(choropleth.df$value))) <= 9) # brewer scale only goes up to 9
ggplot(choropleth.df, aes(long, lat, group = group)) +
geom_polygon(aes(fill = value), color = "dark grey", size = 0.2) +
get_scale() +
theme;
}
}
)
)
# create a map with population estimates
choro = StateChoropleth$new(PolsByState)
choro$render()
StateChoropleth = R6Class("StateChoropleth",
inherit = choroplethr:::Choropleth,
public = list(
# initialize with us state map
initialize = function(user.df)
{
data(state.map)
super$initialize(state.map, user.df)
},
# render the map, with AK and HI as insets
render = function(num_buckets=7)
{
stopifnot(num_buckets > 1 && num_buckets < 10)
self$num_buckets = num_buckets
self$prepare_map()
# if user requested to render all 50 states,
# create separate data.frames for AK and HI and render them as separate images
# cache min, max value of entire data.frame to make scales consistent between all 3 images
min_val = 0
max_val = 0
if (is.numeric(self$choropleth.df$value))
{
min_val = min(self$choropleth.df$value)
max_val = max(self$choropleth.df$value)
}
# subset AK and render it
alaska.df     = self$choropleth.df[self$choropleth.df$region=='alaska',]
alaska.ggplot = render_helper(alaska.df, "", self$theme_inset(), min_val, max_val)
alaska.grob   = ggplotGrob(alaska.ggplot)
# subset HI and render it
hawaii.df     = self$choropleth.df[self$choropleth.df$region=='hawaii',]
hawaii.ggplot = render_helper(hawaii.df, "", self$theme_inset(), min_val, max_val)
hawaii.grob   = ggplotGrob(hawaii.ggplot)
# remove AK and HI from the "real" df
continental.df = self$choropleth.df[!self$choropleth.df$region %in% c("alaska", "hawaii"), ]
continental.ggplot = render_helper(continental.df, self$scale_name, self$theme_clean(), min_val, max_val) + ggtitle(self$title)
continental.ggplot +
annotation_custom(grobTree(hawaii.grob), xmin=-107.5, xmax=-102.5, ymin=25, ymax=27.5) +
annotation_custom(grobTree(alaska.grob), xmin=-125, xmax=-110, ymin=22.5, ymax=30) +
ggtitle(self$title)
},
render_helper = function(choropleth.df, scale_name, theme, min, max)
{
# maps with numeric values are mapped with a continuous scale
if (is.numeric(choropleth.df$value))
{
ggplot(choropleth.df, aes(long, lat, group = group)) +
geom_polygon(aes(fill = value), color = "white", size = 0.2) +
get_scale() +
theme;
} else { # assume character or factor
stopifnot(length(unique(na.omit(choropleth.df$value))) <= 9) # brewer scale only goes up to 9
ggplot(choropleth.df, aes(long, lat, group = group)) +
geom_polygon(aes(fill = value), color = "dark grey", size = 0.2) +
get_scale() +
theme;
}
}
)
)
# create a map with population estimates
choro = StateChoropleth$new(PolsByState)
choro$render()
StateChoropleth = R6Class("StateChoropleth",
inherit = choroplethr:::Choropleth,
public = list(
# initialize with us state map
initialize = function(user.df)
{
data(state.map)
super$initialize(state.map, user.df)
},
# render the map, with AK and HI as insets
render = function(num_buckets=7)
{
stopifnot(num_buckets > 1 && num_buckets < 10)
self$num_buckets = num_buckets
self$prepare_map()
# if user requested to render all 50 states,
# create separate data.frames for AK and HI and render them as separate images
# cache min, max value of entire data.frame to make scales consistent between all 3 images
min_val = 0
max_val = 0
if (is.numeric(self$choropleth.df$value))
{
min_val = min(self$choropleth.df$value)
max_val = max(self$choropleth.df$value)
}
# subset AK and render it
alaska.df     = self$choropleth.df[self$choropleth.df$region=='alaska',]
alaska.ggplot = render_helper(alaska.df, "", self$theme_inset(), min_val, max_val)
alaska.grob   = ggplotGrob(alaska.ggplot)
# subset HI and render it
hawaii.df     = self$choropleth.df[self$choropleth.df$region=='hawaii',]
hawaii.ggplot = render_helper(hawaii.df, "", self$theme_inset(), min_val, max_val)
hawaii.grob   = ggplotGrob(hawaii.ggplot)
# remove AK and HI from the "real" df
continental.df = self$choropleth.df[!self$choropleth.df$region %in% c("alaska", "hawaii"), ]
continental.ggplot = render_helper(continental.df, self$scale_name, self$theme_clean(), min_val, max_val) + ggtitle(self$title)
continental.ggplot +
annotation_custom(grobTree(hawaii.grob), xmin=-107.5, xmax=-102.5, ymin=25, ymax=27.5) +
annotation_custom(grobTree(alaska.grob), xmin=-125, xmax=-110, ymin=22.5, ymax=30) +
ggtitle(self$title)
},
render_helper = function(choropleth.df, scale_name, theme, min, max)
{
# maps with numeric values are mapped with a continuous scale
if (is.numeric(choropleth.df$value))
{
ggplot(choropleth.df, aes(long, lat, group = group)) +
geom_polygon(aes(fill = value), color = "white", size = 0.2) +
get_scale() +
theme;
} else { # assume character or factor
stopifnot(length(unique(na.omit(choropleth.df$value))) <= 9) # brewer scale only goes up to 9
ggplot(choropleth.df, aes(long, lat, group = group)) +
geom_polygon(aes(fill = value), color = "white", size = 0.2) +
get_scale() +
theme;
}
}
)
)
# create a map with population estimates
choro = StateChoropleth$new(PolsByState)
choro$render()
#' Create a state-level choropleth
#' @export
#' @importFrom dplyr left_join
#' @include usa.R
StateChoropleth = R6Class("StateChoropleth",
inherit = USAChoropleth,
public = list(
show_labels = TRUE,
# initialize with us state map
initialize = function(user.df)
{
data(state.map, package="choroplethrMaps", envir=environment())
state.map$state = state.map$region
super$initialize(state.map, user.df)
if (private$has_invalid_regions)
{
warning("Please see ?state.regions for a list of mappable regions")
}
},
render = function()
{
choropleth = super$render()
# by default, add labels for the lower 48 states
if (self$show_labels) {
df_state_labels = data.frame(long = state.center$x, lat = state.center$y, name=tolower(state.name), label = state.abb)
df_state_labels = df_state_labels[!df_state_labels$name %in% c("alaska", "hawaii"), ]
df_state_labels = df_state_labels[df_state_labels$name %in% private$zoom, ]
choropleth = choropleth + geom_text(data = df_state_labels, aes(long, lat, label = label, group = NULL), color = 'black')
}
choropleth
}
)
)
#' Create a choropleth of US States with sensible defaults.
#'
#' The map used is state.map in the package choroplethrMaps.  See state.regions in
#' the choroplethrMaps package for a data.frame that can help you coerce your regions
#' into the required format.
#'
#' @param df A data.frame with a column named "region" and a column named "value".  Elements in
#' the "region" column must exactly match how regions are named in the "region" column in state.map.
#' @param title An optional title for the map.
#' @param legend An optional name for the legend.
#' @param buckets The number of equally sized buckets to places the values in.  A value of 1
#' will use a continuous scale, and a value in [2, 9] will use that many buckets.
#' @param zoom An optional vector of states to zoom in on. Elements of this vector must exactly
#' match the names of states as they appear in the "region" column of ?state.regions.
#'
#' @examples
#' # demonstrate default parameters - visualization using 7 equally sized buckets
#' data(df_pop_state)
#' state_choropleth(df_pop_state, title="US 2012 State Population Estimates", legend="Population")
#'
#' # demonstrate continuous scale and zoom
#' data(df_pop_state)
#' state_choropleth(df_pop_state,
#'                  title="US 2012 State Population Estimates",
#'                  legend="Population",
#'                  buckets=1,
#'                  zoom=c("california", "oregon", "washington"))
#'
#' # demonstrate how choroplethr handles character and factor values
#' # demonstrate user creating their own discretization of the input
#' data(df_pop_state)
#' df_pop_state$str = ""
#' for (i in 1:nrow(df_pop_state))
#' {
#'   if (df_pop_state[i,"value"] < 1000000)
#'   {
#'     df_pop_state[i,"str"] = "< 1M"
#'   } else {
#'     df_pop_state[i,"str"] = "> 1M"
#'   }
#' }
#' df_pop_state$value = df_pop_state$str
#' state_choropleth(df_pop_state, title="Which states have less than 1M people?")
#'
#' @export
#' @importFrom Hmisc cut2
#' @importFrom stringr str_extract_all
#' @importFrom ggplot2 ggplot aes geom_polygon scale_fill_brewer ggtitle theme theme_grey element_blank geom_text
#' @importFrom ggplot2 scale_fill_continuous scale_colour_brewer
#' @importFrom scales comma
#' @importFrom grid unit
state_choropleth = function(df, title="", legend="", buckets=7, zoom=NULL)
{
c = StateChoropleth$new(df)
c$title  = title
c$legend = legend
c$set_buckets(buckets)
c$set_zoom(zoom)
c$render()
}
#' Create a state-level choropleth
#' @export
#' @importFrom dplyr left_join
#' @include usa.R
StateChoropleth = R6Class("StateChoropleth",
inherit = USAChoropleth,
public = list(
show_labels = TRUE,
# initialize with us state map
initialize = function(user.df)
{
data(state.map, package="choroplethrMaps", envir=environment())
state.map$state = state.map$region
super$initialize(state.map, user.df)
if (private$has_invalid_regions)
{
warning("Please see ?state.regions for a list of mappable regions")
}
},
render = function()
{
choropleth = super$render()
# by default, add labels for the lower 48 states
if (self$show_labels) {
df_state_labels = data.frame(long = state.center$x, lat = state.center$y, name=tolower(state.name), label = state.abb)
df_state_labels = df_state_labels[!df_state_labels$name %in% c("alaska", "hawaii"), ]
df_state_labels = df_state_labels[df_state_labels$name %in% private$zoom, ]
choropleth = choropleth + geom_text(data = df_state_labels, aes(long, lat, label = label, group = NULL), color = 'white')
}
choropleth
}
)
)
#' Create a choropleth of US States with sensible defaults.
#'
#' The map used is state.map in the package choroplethrMaps.  See state.regions in
#' the choroplethrMaps package for a data.frame that can help you coerce your regions
#' into the required format.
#'
#' @param df A data.frame with a column named "region" and a column named "value".  Elements in
#' the "region" column must exactly match how regions are named in the "region" column in state.map.
#' @param title An optional title for the map.
#' @param legend An optional name for the legend.
#' @param buckets The number of equally sized buckets to places the values in.  A value of 1
#' will use a continuous scale, and a value in [2, 9] will use that many buckets.
#' @param zoom An optional vector of states to zoom in on. Elements of this vector must exactly
#' match the names of states as they appear in the "region" column of ?state.regions.
#'
#' @examples
#' # demonstrate default parameters - visualization using 7 equally sized buckets
#' data(df_pop_state)
#' state_choropleth(df_pop_state, title="US 2012 State Population Estimates", legend="Population")
#'
#' # demonstrate continuous scale and zoom
#' data(df_pop_state)
#' state_choropleth(df_pop_state,
#'                  title="US 2012 State Population Estimates",
#'                  legend="Population",
#'                  buckets=1,
#'                  zoom=c("california", "oregon", "washington"))
#'
#' # demonstrate how choroplethr handles character and factor values
#' # demonstrate user creating their own discretization of the input
#' data(df_pop_state)
#' df_pop_state$str = ""
#' for (i in 1:nrow(df_pop_state))
#' {
#'   if (df_pop_state[i,"value"] < 1000000)
#'   {
#'     df_pop_state[i,"str"] = "< 1M"
#'   } else {
#'     df_pop_state[i,"str"] = "> 1M"
#'   }
#' }
#' df_pop_state$value = df_pop_state$str
#' state_choropleth(df_pop_state, title="Which states have less than 1M people?")
#'
#' @export
#' @importFrom Hmisc cut2
#' @importFrom stringr str_extract_all
#' @importFrom ggplot2 ggplot aes geom_polygon scale_fill_brewer ggtitle theme theme_grey element_blank geom_text
#' @importFrom ggplot2 scale_fill_continuous scale_colour_brewer
#' @importFrom scales comma
#' @importFrom grid unit
state_choropleth = function(df, title="", legend="", buckets=7, zoom=NULL)
{
c = StateChoropleth$new(df)
c$title  = title
c$legend = legend
c$set_buckets(buckets)
c$set_zoom(zoom)
c$render()
}
#### Load packages and data ####
# load data, which was scraped from wikipedia on Nov 16th, 2014
PolsByState <- read.csv("./data/PolsByState.csv")
# Prepare
PolsByState$region <- tolower(PolsByState$State)
PolsByState$value <- PolsByState$PercOfPolsOpp * 100
state_choropleth(PolsByState)
